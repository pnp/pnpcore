<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>The PnP Core SDK model | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="The PnP Core SDK model | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/pnp/pnpcore/blob/dev/docs/contributing/readme.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="the-pnp-core-sdk-model">The PnP Core SDK model</h1>

<p>The model in PnP Core SDK is what the SDK users use to interact with Microsoft 365: it defines the model classes (e.g. List), their fields (Title, Description,...) and their operations (e.g. GetAsync or Get). This model has a public part (interfaces) and an implementation (internal, partial classes). In order to translate the model into respective SharePoint REST and/or Microsoft Graph v1.0 or beta queries the model needs to be decorated with attributes. These attributes drive the needed API calls to Microsoft 365 and the serialization of returned responses (JSON) into the model. <strong>As a contributor, extending and enriching the model is how you provide functionality to the developers that will be using this SDK</strong>.</p>
<p><img src="../images/sdk%20overview.png" alt="SDK overview"></p>
<h2 id="where-is-the-code">Where is the code?</h2>
<p>The PnP Core SDK is maintained in the PnP GitHub repository: <a href="https://github.com/pnp/pnpcore">https://github.com/pnp/pnpcore</a>. You'll find:</p>
<ul>
<li>The code of the PnP Core SDK in the <code>src\sdk</code> folder</li>
<li>Examples of how to use the PnP Core SDK in the <code>src\samples</code> folder</li>
<li>Generated code to speed up contribution of new model logic in the <code>src\generated</code> folder</li>
<li>The source of the documentation you are reading right now in the <code>docs</code> folder</li>
</ul>
<h2 id="setting-up-your-environment-for-building-the-pnp-core-sdk">Setting up your environment for building the PnP Core SDK</h2>
<p>Starting to code is simple, pull down the code from GitHub and then use either Visual Studio 2019 or Visual Studio Code. More details can be found in our <a href="setup.html">setup</a> article.</p>
<h2 id="general-model-principles">General model principles</h2>
<p>The model design principles are agnostic to whether the model will be populated via a SharePoint REST or Microsoft Graph call, and therefore starting here to understand the general model principles is advised. Once you understand the model design principles you can learn more about how to decorate the model to work with either SharePoint REST and/or Microsoft Graph. Below picture gives an overview of the used classes in the model based on the Team model implementation:</p>
<p><img src="../images/model%20overview.png" alt="Model overview"></p>
<p>In the model there are 2 types of classes:</p>
<ul>
<li>The majority of the model is built from <strong>model classes</strong></li>
<li>Model classes often live in a collection, so we do have <strong>model collection classes</strong></li>
</ul>
<p>Each of these classes has a public model implemented via interfaces and an internal model implemented via internal partial classes.</p>
<h3 id="model-classes">Model classes</h3>
<p>The model classes are the most commonly used classes in our domain model as they represent a Microsoft 365 object that can be queried via either the SharePoint REST or the Microsoft Graph interface. Samples of model classes are Web, Team, List,...</p>
<h4 id="public-model">Public model</h4>
<p>The public model is built via public interfaces. Below sample shows the public model for a SharePoint List</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Public interface to define a List object of SharePoint Online
/// &lt;/summary&gt;
[ConcreteType(typeof(List))]
public interface IList : IDataModel&lt;IList&gt;, IDataModelGet&lt;IList&gt;, IDataModelLoad&lt;IList&gt;, IDataModelUpdate, IDataModelDelete, IQueryableDataModel
{
    /// &lt;summary&gt;
    /// The Unique ID of the List object
    /// &lt;/summary&gt;
    public Guid Id { get; }

    /// &lt;summary&gt;
    /// Gets or sets the list title
    /// &lt;/summary&gt;
    public string Title { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the description of the list
    /// &lt;/summary&gt;
    public string Description { get; set; }

    // Other properties left for brevity
}
</code></pre>
<p>Each public model:</p>
<ul>
<li>Uses a public interface (e.g. <code>IList</code> in our example) with public fields</li>
<li>Uses the <code>ConcreteType</code> attribute to define the implementation type that belongs to this interface</li>
<li>Has inline documentation on the model class and fields</li>
<li>Always implements the <code>IDataModel&lt;TModel&gt;</code> interface where <code>TModel</code> is the actual interface (e.g. <code>IList</code> in above sample)</li>
<li>Optionally implements the <code>IDataModelLoad&lt;TModel&gt;</code> interface whenever <strong>load</strong> functionality is needed on this model class (most of the models have this)</li>
<li>Optionally implements the <code>IDataModelGet&lt;TModel&gt;</code> interface whenever <strong>get</strong> functionality is needed on this model class (most of the models have this)</li>
<li>Optionally implements the <code>IDataModelUpdate</code> interface whenever <strong>update</strong> functionality in needed on this model class</li>
<li>Optionally implements the <code>IDataModelDelete</code> interface whenever <strong>delete</strong> functionality is needed on this model class</li>
<li>Optionally implements the <code>IQueryableDataModel</code> interface whenever the model supports LINQ querying. This goes hand in hand with using the <code>QueryableDataModelCollection</code> base class for the model's collection class</li>
</ul>
<p>The properties in the model use either basic .Net data types, enumerations, other model/collection types or so called complex types:</p>
<pre><code class="lang-csharp">// Simple .Net type
public string Title { get; set; }

// Enum
public ListReadingDirection Direction { get; set; }

// Other model/collection types
public IListItemCollection Items { get; }

// Complex types (sample comes from the Team model class)
public ITeamFunSettings FunSettings { get; set; }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>When a property is read-only you only need to provide a ´get´ in the public model.</p>
</div>
<h4 id="internal-implementation">Internal implementation</h4>
<p>The internal model implementation is what brings the public model to life: this split approach ensures that library consumers only work with the public model, and as such the library implementation can be updated without breaking the public contract with library consumers. Here's a snippet of the <code>List.cs</code> class:</p>
<pre><code class="lang-csharp">[SharePointType(&quot;SP.List&quot;, Uri = &quot;_api/Web/Lists(guid'{Id}')&quot;, Update = &quot;_api/web/lists/getbyid(guid'{Id}')&quot;, LinqGet = &quot;_api/web/lists&quot;)]
[GraphType(Get = &quot;sites/{Parent.GraphId}/lists/{GraphId}&quot;, LinqGet = &quot;sites/{Parent.GraphId}/lists&quot;)]
internal partial class List : BaseDataModel&lt;IList&gt;, IList
{
    public List()
    {
        // Handler to construct the Add request for this list
        AddApiCallHandler = () =&gt;
        {
            var entity = EntityManager.GetClassInfo(GetType(), this);

            var addParameters = new
            {
                __metadata = new { type = entity.SharePointType },
                BaseTemplate = TemplateType,
                Title
            }.AsExpando();
            string body = JsonSerializer.Serialize(addParameters, typeof(ExpandoObject));
            return new ApiCall($&quot;_api/web/lists&quot;, ApiType.SPORest, body);
        };
    }

    public Guid Id { get =&gt; GetValue&lt;Guid&gt;(); set =&gt; SetValue(value); }

    [GraphProperty(&quot;displayName&quot;)]
    public string Title { get =&gt; GetValue&lt;string&gt;(); set =&gt; SetValue(value); }

    [GraphProperty(&quot;description&quot;)]
    public string Description { get =&gt; GetValue&lt;string&gt;(); set =&gt; SetValue(value); }

    public IFolder RootFolder { get =&gt; GetModelValue&lt;IFolder&gt;(); }

    [GraphProperty(&quot;items&quot;, Get = &quot;/sites/{Web.GraphId}/lists/{GraphId}/items?expand=fields&quot;)]
    public IListItemCollection Items { get =&gt; GetModelCollectionValue&lt;IListItemCollection&gt;(); }

    // Other properties left for brevity

    [KeyProperty(nameof(Id))]
    public override object Key { get =&gt; this.Id; set =&gt; this.Id = Guid.Parse(value.ToString()); }
}
</code></pre>
<p>Each model class:</p>
<ul>
<li><p>Inherits from the <code>BaseDataModel&lt;TModel&gt;</code> class and implements <code>TModel</code></p>
</li>
<li><p>Is an <strong>internal</strong>, <strong>partial</strong> class</p>
</li>
<li><p>Does have a public default constructor</p>
</li>
<li><p>Can implement event handlers which are used to (see the <a href="event%20handlers.html">Event Handlers</a> page for more details):</p>
<ul>
<li>Optionally customize the JSON to Model mapping via the <code>MappingHandler = (FromJson input)</code> handler</li>
<li>Implement the API call for doing an Add operation via the <code>AddApiCallHandler = async ()</code> handler</li>
<li>Optionally implement API call overrides that allow you to update the generated API call before it's sent off to the server. There are these handlers: <code>GetApiCallOverrideHandler = async (ApiCall apiCall)</code>, <code>UpdateApiCallOverrideHandler = async (ApiCall apiCall)</code> and <code>DeleteApiCallOverrideHandler = async (ApiCall apiCall)</code></li>
<li>Optionally implement property validation (prevent property updates, alter values) via the <code>ValidateUpdateHandler = (ref FieldUpdateRequest fieldUpdateRequest)</code> handler</li>
</ul>
</li>
<li><p>Contains class level attributes that are used to define the requests to Microsoft 365 and serialization of the received data. These attributes are explained in more detail in their respective chapters later on</p>
</li>
<li><p>Has public properties that:</p>
<ul>
<li>Use the <code>GetValue</code> and <code>SetValue</code> inherited methods to get and set simple property values</li>
<li>Use the <code>GetModelValue</code> and optionally <code>SetModelValue</code> base class methods to get and set model property values (e.g. <code>IFolder</code>)</li>
<li>Use the <code>GetModelCollectionValue</code> base class method to get a model collection property value (e.g. <code>IListItemCollection</code>)</li>
</ul>
</li>
<li><p>Has a <code>Key</code> property override which can be used to set/get the key value. The Key is used to organize objects in collections</p>
</li>
<li><p>Has property attributes that are used to define the requests to Microsoft 365 and serialization of the received data. These attributes are explained in more detail in their respective chapters later on</p>
</li>
<li><p>Model specific methods can be foreseen. These methods provide additional operations on the model class</p>
</li>
</ul>
<h3 id="collection-classes">Collection classes</h3>
<p>Collection classes contain zero or more model class instances, so for example the <code>ListCollection</code> will contain zero or more <code>List</code> model class instances.</p>
<h4 id="public-model-1">Public model</h4>
<p>The public model is built via public interfaces. Below sample shows the public model for a SharePoint ListCollection</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Public interface to define a collection of List objects of SharePoint Online
/// &lt;/summary&gt;
[ConcreteType(typeof(ListCollection))]
public interface IListCollection : IDataModelCollection&lt;IList&gt;, IDataModelCollectionLoad&lt;IList&gt;, IQueryable&lt;IList&gt;, IDataModelCollectionDeleteByGuidId, IAsyncEnumerable&lt;IList&gt;
{
    /// &lt;summary&gt;
    /// Adds a new list
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;Title of the list&lt;/param&gt;
    /// &lt;param name=&quot;templateType&quot;&gt;Template type&lt;/param&gt;
    /// &lt;returns&gt;Newly added list&lt;/returns&gt;
    public Task&lt;IList&gt; AddAsync(string title, int templateType);

    /// &lt;summary&gt;
    /// Select a list by title
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to search for&lt;/param&gt;
    /// &lt;param name=&quot;selectors&quot;&gt;The expressions declaring the fields to select&lt;/param&gt;
    /// &lt;returns&gt;The resulting list instance, if any&lt;/returns&gt;
    public Task&lt;IList&gt; GetByTitleAsync(string title, params Expression&lt;Func&lt;IList, object&gt;&gt;[] selectors);

    // Other methods omitted for brevity

}
</code></pre>
<p>Each public model interface for a Collection class:</p>
<ul>
<li>Uses a public interface (e.g. <code>IListCollection</code> in our example) with optionally public methods</li>
<li>Contains the implementation of the methods defined in the public interface</li>
<li>Has inline documentation on the model class and methods</li>
<li>Always implements the <code>IDataModelCollection&lt;TModel&gt;</code> interface where <code>TModel</code> is the actual interface (e.g. <code>IList</code> in above sample)</li>
<li>Optionally implements the <code>IDataModelCollectionLoad&lt;TModel&gt;</code> interface where <code>TModel</code> is the actual interface (e.g. <code>IList</code> in above sample) whenever the collection can loaded</li>
<li>Optionally implements the <code>IQueryable&lt;TModel&gt;</code> interface where <code>TModel</code> is the actual interface (e.g. <code>IList</code> in above sample) whenever the model can be queried using linq queries</li>
<li>Optionally implements the <code>IAsyncEnumerable&lt;TModel&gt;</code> interface whenever the data in the collection can be asynchronously enumerated</li>
<li>Optionally implements either the <code>IDataModelCollectionDeleteByGuidId</code>, <code>IDataModelCollectionDeleteByIntegerId</code> or <code>IDataModelCollectionDeleteByStringId</code> interface matching the data type of the collection model's key if you want to offer a <code>DeleteById</code> method on the model collection. You should only do this if you've also implemented the <code>IDataModelDelete</code> on the collection's model</li>
</ul>
<p>Optionally a collection interface defines methods which add behavior to the collection.</p>
<h4 id="internal-implementation-1">Internal implementation</h4>
<p>For the internal collection class implementation, we've opted to use internal partial classes. Here's a snippet of the <code>ListCollection.cs</code> class, which is linq queryable:</p>
<pre><code class="lang-csharp">internal partial class ListCollection : QueryableDataModelCollection&lt;IList&gt;, IListCollection
{
    public ListCollection(PnPContext context, IDataModelParent parent, string memberName = null)
        : base(context, parent, memberName)
    {
        this.PnPContext = context;
        this.Parent = parent;
    }

    // Other methods omitted for brevity

    public async Task&lt;IList&gt; AddAsync(string title, int templateType)
    {
        if (title == null)
        {
            throw new ArgumentNullException(nameof(title));
        }

        if (templateType == 0)
        {
            throw new ArgumentException($&quot;{nameof(templateType)} cannot be 0&quot;);
        }

        var newList = CreateNewAndAdd() as List;

        newList.Title = title;
        newList.TemplateType = templateType;

        return await newList.AddAsync().ConfigureAwait(false) as List;
    }

    public async Task&lt;IList&gt; GetByTitleAsync(string title, params Expression&lt;Func&lt;IList, object&gt;&gt;[] selectors)
    {
        if (title == null)
        {
            throw new ArgumentNullException(nameof(title));
        }

        return await BaseDataModelExtensions.BaseLinqGetAsync(this, l =&gt; l.Title == title, selectors).ConfigureAwait(false);
    }

    // Other methods omitted for brevity
}
</code></pre>
<p>If the collection is not linq queryable the collection class is very simple:</p>
<pre><code class="lang-csharp">internal partial class TeamAppCollection : BaseDataModelCollection&lt;ITeamApp&gt;, ITeamAppCollection
{ }
</code></pre>
<p>Each collection class:</p>
<ul>
<li>Inherits from either the <code>BaseDataModelCollection&lt;TModel&gt;</code> for regular collections or from the <code>QueryableDataModelCollection&lt;TModel&gt;</code> class for linq queryable collections and implements the previously created collection interface (e.g. <code>IListCollection</code>)</li>
<li>Is an <strong>internal</strong>, <strong>partial</strong> class</li>
<li>Implements a specific constructor in case the class inherits from <code>QueryableDataModelCollection&lt;TModel&gt;</code></li>
<li>Can use the <code>CreateNewAndAdd</code> collection base class method to create a new instance and add it to the collection</li>
</ul>
<h2 id="decorating-the-model">Decorating the model</h2>
<p>The model, collections and complex type classes you create can be populated via either SharePoint REST queries, Microsoft Graph queries or both. Depending on the needed query approach you'll need to decorate the model classes and/or fields with properties. <strong>It's these properties that drive the automatic query generation</strong>.</p>
<p>When you populate your model via SharePoint REST queries then continue <a href="extending%20the%20model%20-%20SharePoint%20REST.html">here</a>, in case the model is populated via Microsoft Graph continue <a href="extending%20the%20model%20-%20Microsoft%20Graph.html">here</a>.</p>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>    
    <!-- <img src="https://m365-visitor-stats.azurewebsites.net/pnpcoresdk/docs" /> -->
  </body>
</html>