<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Working with list items | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Working with list items | PnP Core SDK ">
    <meta name="generator" content="docfx 2.56.5.0">
    <meta name="description" content="The PnP Core SDK is an SDK designed to work against Microsoft 365. Its aim is to provide a unified object model to work with the whole Microsoft 365 ecosystem. ">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/pnp/pnpcore/blob/dev/docs/using-the-sdk/listitems-intro.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="working-with-list-items">Working with list items</h1>

<p>List items are a key part of SharePoint and reading, creating, updating and deleting list items is commonly used. In this chapter we'll explain how you use the PnP Core SDK to work with list items.</p>
<p>In the remainder of this article you'll see a lot of <code>context</code> use: in this case this is a <code>PnPContext</code> which was obtained via the <code>PnPContextFactory</code> as explained in the <a href="readme.html">overview article</a> and show below:</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // See next chapter on how to use the PnPContext for working with list items
}
</code></pre>
<h2 id="reading-list-items">Reading list items</h2>
<p>The PnP Core SDK supports multiple ways to read list items and what approach to use depends on your list size and your use case. For a large list you want to consider <a href="basics-getdata-paging.html">using paging</a> and it's also recommended to write a query that only returns the items you really need versus loading all list items. When writing custom queries you also should consider only returning the list fields you need in your application, the lesser rows and fields to return the faster the response will come from the server.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>When processing list item responses from the server the SDK will translate the server response into a easy to use field value classes in case of complex field types. This feature depends on the List field information being present, you can load your list field information once when you get load your list like (<code>var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));</code>). The minimal required field properties are <code>InternalName</code>, <code>FieldTypeKind</code>, <code>TypeAsString</code> and <code>Title</code>.</p>
</div>
<h3 id="getting-all-list-items">Getting all list items</h3>
<p>If you simply want to load all list items and your list is not containing a lot of items you load the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IList.html#PnP_Core_Model_SharePoint_IList_Items">Items property</a> of your list.</p>
<pre><code class="lang-csharp">// Assume the fields where not yet loaded, so loading them with the list
var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, 
                                                     p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));
// Get the item with title &quot;Item1&quot;
var addedItem = myList.Items.FirstOrDefault(p =&gt; p.Title == &quot;Item1&quot;);

// Iterate over the retrieved list items
foreach (var listItem in myList.Items)
{
    // Do something with the list item
}
</code></pre>
<h3 id="getting-list-items-via-a-caml-query">Getting list items via a CAML query</h3>
<p>SharePoint <a href="https://docs.microsoft.com/en-us/sharepoint/dev/schema/query-schema">CAML</a> queries allow you to express a filter when loading list item data and scope down the loaded fields to the ones you need. You can use call the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IList.html#PnP_Core_Model_SharePoint_IList_GetItemsByCamlQueryAsync_PnP_Core_Model_SharePoint_CamlQueryOptions_">GetItemsByCamlQueryAsync method</a> on an <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IList.html">IList</a> for this purpose. When using this method you can either provide the CAML query directly or use the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.CamlQueryOptions.html">CamlQueryOptions</a> class for more fine-grained control. If you use this class you typically would use the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.CamlQueryOptions.html#collapsible-PnP_Core_Model_SharePoint_CamlQueryOptions_ViewXml">ViewXml property</a>, but also <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.CamlQueryOptions.html#collapsible-PnP_Core_Model_SharePoint_CamlQueryOptions_FolderServerRelativeUrl">FolderServerRelativeUrl</a> is used a lot to scope the query to given folder in the list.</p>
<pre><code class="lang-csharp">// Assume the fields where not yet loaded, so loading them with the list
var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, 
                                                     p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));

// Build a query that only returns the Title field for items where the Title field starts with &quot;Item1&quot;
string viewXml = @&quot;&lt;View&gt;
                    &lt;ViewFields&gt;
                      &lt;FieldRef Name='Title' /&gt;
                    &lt;/ViewFields&gt;
                    &lt;Query&gt;
                      &lt;Where&gt;
                        &lt;BeginsWith&gt;
                          &lt;FieldRef Name='Title'/&gt;
                          &lt;Value Type='text'&gt;Item1&lt;/Value&gt;
                        &lt;/BeginsWith&gt;
                      &lt;/Where&gt;
                    &lt;/Query&gt;
                   &lt;/View&gt;&quot;;

// Execute the query
await myList.GetItemsByCamlQueryAsync(new CamlQueryOptions()
{
    ViewXml = viewXml,
    DatesInUtc = true
});

// Iterate over the retrieved list items
foreach (var listItem in myList.Items)
{
    // Do something with the list item
}
</code></pre>
<h4 id="using-paging-with-caml-queries">Using paging with CAML queries</h4>
<p>By setting a row limit in the CAML query combined with using the the PagingInfo attribute of the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.CamlQueryOptions.html">CamlQueryOptions</a> class you can use CAML queries to load data in a paged manner. Below snippet shows the initial page load getting 20 items and the next one getting the next 20 items.</p>
<pre><code class="lang-csharp">// Assume the fields where not yet loaded, so loading them with the list
var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, 
                                                     p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));

// Build a query that only returns the first 20 rows where the Title field starts with &quot;Item1&quot;
string viewXml = @&quot;&lt;View&gt;
                    &lt;ViewFields&gt;
                      &lt;FieldRef Name='Title' /&gt;
                    &lt;/ViewFields&gt;
                    &lt;Query&gt;
                      &lt;Where&gt;
                        &lt;BeginsWith&gt;
                          &lt;FieldRef Name='Title'/&gt;
                          &lt;Value Type='text'&gt;Item1&lt;/Value&gt;
                        &lt;/BeginsWith&gt;
                      &lt;/Where&gt;
                    &lt;/Query&gt;
                    &lt;RowLimit&gt;20&lt;/RowLimit&gt;
                   &lt;/View&gt;&quot;;

// Execute the query loading the first 20
await myList.GetItemsByCamlQueryAsync(new CamlQueryOptions()
{
    ViewXml = viewXml,
    DatesInUtc = true
});

// Execute the query loading the next 20
await myList.GetItemsByCamlQueryAsync(new CamlQueryOptions()
{
    ViewXml = viewXml,
    DatesInUtc = true,
    PagingInfo = $&quot;Paged=TRUE&amp;p_ID={list2.Items.Last().Id}&quot;
});

// Iterate over the retrieved list items
foreach (var listItem in myList.Items)
{
    // Do something with the list item
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>If you're query is ordered by one or more fields these fields also have to specified in the PagingInfo, e.g. if ordered on Title the PagingInfo would be <code>$&quot;Paged=TRUE&amp;p_ID={list2.Items.Last().Id}&amp;p_Title=${list2.Items.Last().Title}&quot;</code>. If you want to load the previous page you also need to add <code>&amp;PagedPrev=TRUE</code>.</p>
</div>
<h3 id="using-the-listdataasstream-approach">Using the ListDataAsStream approach</h3>
<p>Using the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IList.html#PnP_Core_Model_SharePoint_IList_GetListDataAsStreamAsync_PnP_Core_Model_SharePoint_RenderListDataOptions_">GetListDataAsStreamAsync method</a> gives you the most control over how to query the list and what data to return. Using this method is similar to the above described <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IList.html#PnP_Core_Model_SharePoint_IList_GetItemsByCamlQueryAsync_PnP_Core_Model_SharePoint_CamlQueryOptions_">GetItemsByCamlQueryAsync method</a> as you typically specify a <a href="https://docs.microsoft.com/en-us/sharepoint/dev/schema/query-schema">CAML</a> query when using this method. To configure the input of this method you need to use the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.RenderListDataOptions.html">RenderListDataOptions class</a>. Defining the CAML query to run can be done via the ViewXml property and telling what type of data to return can be done via the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.RenderListDataOptions.html#PnP_Core_Model_SharePoint_RenderListDataOptions_RenderOptions">RenderOptions</a> property.</p>
<pre><code class="lang-csharp">// Assume the fields where not yet loaded, so loading them with the list
var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, 
                                                     p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));

// Build a query that only returns the Title field for the top 5 items where the Title field starts with &quot;Item1&quot;
string viewXml = @&quot;&lt;View&gt;
                    &lt;ViewFields&gt;
                      &lt;FieldRef Name='Title' /&gt;
                    &lt;/ViewFields&gt;
                    &lt;Query&gt;
                      &lt;Where&gt;
                        &lt;BeginsWith&gt;
                          &lt;FieldRef Name='Title'/&gt;
                          &lt;Value Type='text'&gt;Item1&lt;/Value&gt;
                        &lt;/BeginsWith&gt;
                      &lt;/Where&gt;
                    &lt;/Query&gt;
                    &lt;RowLimit&gt;5&lt;/RowLimit&gt;
                   &lt;/View&gt;&quot;;

// Execute the query
var output = await myList.GetListDataAsStreamAsync(new RenderListDataOptions()
{
    ViewXml = viewXml,
    RenderOptions = RenderListDataOptionsFlags.ListData
});

// If needed do something with the output, e.g. (int)result[&quot;LastRow&quot;] tells you the last loaded row

// Iterate over the retrieved list items
foreach (var listItem in myList.Items)
{
    // Do something with the list item
}
</code></pre>
<h2 id="adding-list-items">Adding list items</h2>
<p>Adding list items is done using one of the Add methods on the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IListItemCollection.html">ListItemCollection class</a>, e.g. the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IListItemCollection.html#PnP_Core_Model_SharePoint_IListItemCollection_AddAsync_Dictionary_System_String_System_Object__">AddAsync method</a> and requires two steps:</p>
<ul>
<li>You fill a <code>Dictionary&lt;string, object&gt;</code> with fields and their needed value</li>
<li>You send the assembled data to the server via one of the Add methods</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Below examples use simple fields like a Text and Number field, check out the <a href="listitems-fields.html">working with complex list item fields</a> article to learn more about how to use complex fields (e.g. Taxonomy, User,...) with list items.</p>
</div>
<pre><code class="lang-csharp">// Fill a dictionary with fields and their value
Dictionary&lt;string, object&gt; item = new Dictionary&lt;string, object&gt;()
{
    { &quot;Title&quot;, &quot;Item1&quot; },
    { &quot;Field A&quot;, 25 }
};

// Persist the item
var addedItem = await myList.Items.AddAsync(item);
</code></pre>
<p>When you add list items you quite often need to add multiple items and the best way to do that is using the Batch methods (e.g. <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IListItemCollection.html#PnP_Core_Model_SharePoint_IListItemCollection_AddBatchAsync_Dictionary_System_String_System_Object__">AddBatchAsync</a>), the lesser server roundtrips the faster your code will be.</p>
<pre><code class="lang-csharp">// Add 20 items to the list
for (int i = 0; i &lt; 20; i++)
{
    Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
    {
        { &quot;Title&quot;, $&quot;Item {i}&quot; }
    };

    // Use the AddBatch method to add the request to the current batch
    await myList.Items.AddBatchAsync(values);
}

// Execute all added batch requests as a single request to the server
await context.ExecuteAsync();
</code></pre>
<h2 id="updating-list-items">Updating list items</h2>
<p>Updating a list item comes down to updating the field values followed by calling an <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IListItem.html">IListItem</a> Update method such as <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.IDataModelUpdate.html#PnP_Core_Model_IDataModelUpdate_UpdateAsync">UpdateAsync</a>. Depending on how you want to do the update you do have alternative methods:</p>
<table>
<thead>
<tr>
<th>Methods</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Update, UpdateAsync</td>
<td>Regular update, this will result in a new version being created and the modified and editor list item fields will be updated</td>
</tr>
<tr>
<td>SystemUpdate, SystemUpdateAsync</td>
<td>Updates the item without creating a new version and without updating the modified and editor list item fields</td>
</tr>
<tr>
<td>UpdateOverWriteVersion, UpdateOverWriteVersionAsync</td>
<td>Updates the item without creating a new version and the modified and editor list item fields will be updated</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Below examples use simple fields like a Text and Number field, check out the <a href="listitems-fields.html">working with complex list item fields</a> article to learn more about how to use complex fields (e.g. Taxonomy, User,...) with list items.</p>
</div>
<pre><code class="lang-csharp">// Fill a dictionary with fields and their value
Dictionary&lt;string, object&gt; item = new Dictionary&lt;string, object&gt;()
{
    { &quot;Title&quot;, &quot;Item1&quot; },
    { &quot;Field A&quot;, 25 }
};

// Persist the item
var addedItem = await myList.Items.AddAsync(item);

// Update the item values
addedItem[&quot;Field A&quot;] = 100;

// Update the item in SharePoint
await addedItem.UpdateAsync();
</code></pre>
<h2 id="deleting-list-items">Deleting list items</h2>
<p>Using the Delete methods like DeleteAsync or DeleteBatchAsync you can delete one or more list items in a single server roundtrip. Batching is preferred if you need to delete multiple list items.</p>
<pre><code class="lang-csharp">// Assume the fields where not yet loaded, so loading them with the list
var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, 
                                                     p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));
// Iterate over the retrieved list items
foreach (var listItem in myList.Items)
{
    // Delete all the items in &quot;My List&quot; by adding them to a batch
    await listItem.DeleteBatchAsync();
}

// Execute the batch
await context.ExecuteAsync();
</code></pre>
<h2 id="other-list-item-operations">Other list item operations</h2>
<h3 id="enablingdisabling-list-item-comments">Enabling/Disabling list item comments</h3>
<p>List items can have comments in SharePoint and using the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IListItemBase.html#PnP_Core_Model_SharePoint_IListItemBase_SetCommentsDisabledAsync_System_Boolean_">SetCommentsDisabledAsync method</a> you can turn off commenting for a given list item. This method goes hand in hand with the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Model.SharePoint.IListItemBase.html#PnP_Core_Model_SharePoint_IListItemBase_AreCommentsDisabledAsync">AreCommentsDisabledAsync</a> method to get the current commenting status of a list item.</p>
<pre><code class="lang-csharp">// Assume the fields where not yet loaded, so loading them with the list
var myList = context.Web.Lists.GetByTitle(&quot;My List&quot;, p =&gt; p.Title, p =&gt; p.Items, 
                                                     p =&gt; p.Fields.LoadProperties(p =&gt; p.InternalName, p =&gt; p.FieldTypeKind, p =&gt; p.TypeAsString, p =&gt; p.Title));
// Get the item with title &quot;Item1&quot;
var addedItem = myList.Items.FirstOrDefault(p =&gt; p.Title == &quot;Item1&quot;);

// Check if commenting was turned off
if (!(await addedItem.AreCommentsDisabledAsync()))
{
    // Turn commenting of the list item on
    await addedItem.SetCommentsDisabledAsync(false);
}
</code></pre>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>  </body>
</html>