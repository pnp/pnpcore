<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Working with taxonomy data: an introduction | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Working with taxonomy data: an introduction | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/pnp/pnpcore/blob/dev/docs/using-the-sdk/taxonomy-intro.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="working-with-taxonomy-data-an-introduction">Working with taxonomy data: an introduction</h1>

<p>The application that create might need taxonomy data or you might need to create taxonomy data like term groups, term sets and terms. All of this is possible using PnP Core SDK as explained in this article.</p>
<p>In the remainder of this article you'll see a lot of <code>context</code> use: in this case this is a <code>PnPContext</code> which was obtained via the <code>PnPContextFactory</code> as explained in the <a href="readme.html">overview article</a> and show below:</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // See next chapter on how to use the PnPContext for adding, updating and deleting data
}
</code></pre>
<h2 id="working-the-term-store">Working the term store</h2>
<p>All taxonomy objects like term groups, term sets and terms live in a term store. This term store can be access via the <code>TermStore</code> property of the <code>PnPContext</code> you're using:</p>
<pre><code class="lang-csharp">var termStore = await context.TermStore.GetAsync();
</code></pre>
<p>The <code>TermStore</code> property is the entry point to all the taxonomy data, but it can also be configured. Typical configurations on a term store are adding additional languages or updating the default term store language.</p>
<pre><code class="lang-csharp">var termStore = await context.TermStore.GetAsync();

if (!termStore.Languages.Contains(&quot;nl-NL&quot;))
{
    // Add a new language
    termStore.Languages.Add(&quot;nl-NL&quot;);
    await termStore.UpdateAsync();
}
</code></pre>
<p>Removing a term language can be done as well:</p>
<pre><code class="lang-csharp">var termStore = await context.TermStore.GetAsync();

if (termStore.Languages.Contains(&quot;nl-NL&quot;))
{
    // Remove a language
    termStore.Languages.Remove(&quot;nl-NL&quot;);
    await termStore.UpdateAsync();
}
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>If your application is using application permissions when working with taxonomy you'll need to ensure you've added SharePoint principal as termstore administrator. Navigate to <a href="https://contoso-admin.sharepoint.com/_layouts/15/TermStoreManager.aspx">https://contoso-admin.sharepoint.com/_layouts/15/TermStoreManager.aspx</a> (update to match your tenant name) and add <code>i:0i.t|00000003-0000-0ff1-ce00-000000000000|app@sharepoint</code> to the list of Term Store Administrators. If that page is not available anymore in your tenant you can use PnP PowerShell to add the SharePoint Principal: below code will replace the existing admins with the app principal one, so first take note of the added admins or alternatively update the payload of the request:</p>
<pre><code class="lang-powershell">$body = &quot;{`&quot;administrators`&quot;:[{`&quot;user`&quot;: { `&quot;email`&quot;: `&quot;app@sharepoint`&quot;, `&quot;userPrincipalName`&quot;: `&quot;i:0i.t|00000003-0000-0ff1-ce00-000000000000|app@sharepoint`&quot;, displayName: `&quot;SharePoint App`&quot; }}]}&quot;
Invoke-PnPSPRestMethod -Method PATCH -Url &quot;/_api/v2.1/termStore?select=*,administrators&quot; -Raw -Content $body
</code></pre>
</div>
<h2 id="working-with-term-groups">Working with term groups</h2>
<p>Term groups are used to organize term sets and define permissions on who can manage or author new term sets and terms in the group. To get term groups you can either load all term groups, use a LINQ query to load specific groups or get a term group by id or name:</p>
<pre><code class="lang-csharp">// Load all term groups
await context.TermStore.LoadAsync(p =&gt; p.Groups);

// Load specific term groups using a LINQ query
var myTermGroup = await context.TermStore.Groups.Where(p =&gt; p.Name == &quot;MyTermSets&quot;).FirstOrDefaultAsync();

// Get a term group by name (equivalent to previous LINQ query)
var myTermGroup = await context.TermStore.Groups.GetByNameAsync(&quot;MyTermSets&quot;);

// Get a term group by id
var myTermGroup = await context.TermStore.Groups.GetByIdAsync(&quot;0e8f395e-ff58-4d45-9ff7-e331ab728beb&quot;);
</code></pre>
<p>Adding a term group is done using the <code>Add</code> methods on the <code>ITermGroupCollection</code>:</p>
<pre><code class="lang-csharp">var myNewGroup = await context.TermStore.Groups.AddAsync(&quot;My New Group&quot;, &quot;Optional group description&quot;);
</code></pre>
<p>Once you've a reference to a term group you can also update that term group:</p>
<pre><code class="lang-csharp">myNewGroup.Name = &quot;Updated name!&quot;;
await myNewGroup.UpdateAsync();
</code></pre>
<p>Deleting a term group can be done using the <code>Delete</code> methods:</p>
<pre><code class="lang-csharp">await myNewGroup.DeleteAsync();
</code></pre>
<h2 id="working-with-term-sets">Working with term sets</h2>
<p>Term sets are the container for the terms and term sets themselves always are part of a term group. So to work with term sets you typically go via the term group. You can opt to load all term sets in a term group, write a LINQ query or get a term set by id:</p>
<pre><code class="lang-csharp">// Get the term group hosting the needed term set 
var myTermGroup = await context.TermStore.Groups.GetByIdAsync(&quot;0e8f395e-ff58-4d45-9ff7-e331ab728beb&quot;);

// Load all term sets in the group
await myTermGroup.LoadAsync(p =&gt; p.Sets);
foreach(var termSet in myTermGroup.Sets.AsRequested())
{
    // Use the term set
}

// Write a LINQ query to load a term set
var termSet = await myTermGroup.Sets.Where(p =&gt; p.Id == &quot;2374aacb-8c25-4991-aa94-7585bcedf38d&quot;).FirstOrDefaultAsync();

// Get a term set by id, identical to above LINQ approach
var termSet = await myTermGroup.Sets.GetByIdAsync(&quot;2374aacb-8c25-4991-aa94-7585bcedf38d&quot;);
</code></pre>
<p>When you know the term set id you an directly get the term set via the <code>GetTermSetById</code> methods on the <code>ITermStore</code>:</p>
<pre><code class="lang-csharp">var termSet = await context.TermStore.GetTermSetByIdAsync(&quot;2374aacb-8c25-4991-aa94-7585bcedf38d&quot;, p =&gt; p.Description, p =&gt; p.Group);
</code></pre>
<p>Adding a term set to a term group is done using the <code>Add</code> methods on the <code>ITermSetCollection</code>:</p>
<pre><code class="lang-csharp">var termSet = await myTermGroup.Sets.AddAsync(&quot;MyTermSet&quot;, &quot;Optional set description&quot;);
</code></pre>
<p>Once you've a reference to a term set you can also update that term set:</p>
<pre><code class="lang-csharp">// Update the term set description
termSet.Description = &quot;updated description&quot;;
// Add a new localized label for the term set
(termSet.LocalizedNames as TermSetLocalizedNameCollection).Add(new TermSetLocalizedName() { LanguageTag = &quot;nl-NL&quot;, Name = &quot;Dutch name&quot; });
// Send the updates to the server
await termSet.UpdateAsync();
</code></pre>
<p>Deleting a term set can be done using the <code>Delete</code> methods:</p>
<pre><code class="lang-csharp">await termSet.DeleteAsync();
</code></pre>
<h2 id="working-with-terms">Working with terms</h2>
<p>A term set can hold one or more terms and each term on it's own can hold other terms...so you can have a term hierarchy. As terms live in a term set working with terms means first getting the term set, like shown in previous chapter. If you want to work with terms you first need to load them and this can be done by loading all terms, by writing a LINQ query or by getting a term by id:</p>
<pre><code class="lang-csharp">// Load all terms in a term set that have the term set as parent
await termSet.LoadAsync(p =&gt; p.Terms);

foreach (var term in termSet.Terms.AsRequested())
{
    // Load the child terms of this term
    await term.LoadAsync(p =&gt; p.Terms);
    foreach (var childTerm in term.Terms.AsRequested())
    {
        // Do something with the term
    }

    // Do something with the term
}

// Load terms via a LINQ query
var term = await termSet.Terms.Where(p =&gt; p.Id == &quot;6b39335d-1975-4fd7-9696-b40d57c9bde7&quot;).FirstOrDefaultAsync();

// Get a term by id from a term set
var term = await termSet.Terms.GetByIdAsync(&quot;6b39335d-1975-4fd7-9696-b40d57c9bde7&quot;);

// Get a term by id from another term
var childTerm = await term.Terms.GetByIdAsync(&quot;2dd726ce-1f14-4113-be57-5e0bc2d28914&quot;);
</code></pre>
<p>When you know the term set id and term id you an directly get the term via the <code>GetTermById</code> methods on the <code>ITermStore</code>:</p>
<pre><code class="lang-csharp">var term = await context.TermStore.GetTermByIdAsync(&quot;2374aacb-8c25-4991-aa94-7585bcedf38d&quot;, &quot;6b39335d-1975-4fd7-9696-b40d57c9bde7&quot;, p =&gt; p.Descriptions, p =&gt; p.Set);
</code></pre>
<p>If you want to enumerate all terms in a hierarchical termset, then below code snippet shows how to combine batching and recursive code to load all the terms in the most efficient manner:</p>
<pre><code class="lang-csharp">var termset = context.TermStore.GetTermSetById(&quot;4b000117-03c4-4b2b-81f4-21e2ab26d6be&quot;, p =&gt; p.Description, p =&gt; p.Terms);

// recursively load the terms in the termset
await LoadTermsAsync(termset.Terms);

private async Task LoadTermsAsync(ITermCollection terms)
{
    var batch = terms.PnPContext.NewBatch();

    foreach (var term in terms.AsRequested())
    {
        await term.LoadBatchAsync(batch, p =&gt; p.Labels, p =&gt; p.Terms);
    }

    await terms.PnPContext.ExecuteAsync(batch);

    foreach (var term in terms.AsRequested())
    {
        if (term.Terms.AsRequested().Count() &gt; 0)
        {
            // Load the possible child terms
            await LoadTermsAsync(term.Terms);
        }
    }
}
</code></pre>
<p>Adding a term to a term set or another term is done using the <code>Add</code> methods on the <code>ITermCollection</code>:</p>
<pre><code class="lang-csharp">// Add term at term set level, the default term store language will be assumed for the language of the name/description
var newTerm = await termSet.Terms.AddAsync(&quot;MyTerm&quot;, &quot;Optional term description&quot;);

// Add child term to another term, the default term store language will be assumed for the language of the name/description
var childTerm = await newTerm.Terms.AddAsync(&quot;MyChildTerm&quot;, &quot;Optional term description&quot;);
</code></pre>
<p>Once you've a reference to a term you can also update that term:</p>
<pre><code class="lang-csharp">// Add a new term label for language fr-FR
// Note: fr-FR must be a language allowed in the term store
newTerm.AddLabelAndDescription(&quot;French label&quot;, &quot;fr-FR&quot;, false, &quot;Optional term description&quot;);
await newTerm.UpdateAsync();
</code></pre>
<p>Deleting a term can be done using the <code>Delete</code> methods:</p>
<pre><code class="lang-csharp">await term.DeleteAsync();
</code></pre>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>    
    <img src="https://m365-visitor-stats.azurewebsites.net/pnpcoresdk/docs">
  </body>
</html>