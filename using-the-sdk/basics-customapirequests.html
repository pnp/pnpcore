<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Making custom API calls | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Making custom API calls | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/pnp/pnpcore/blob/dev/docs/using-the-sdk/basics-customapirequests.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="making-custom-api-calls">Making custom API calls</h1>

<p>PnP Core SDK uses a strongly typed model allowing you to interact with SharePoint and Microsoft Teams using either SharePoint REST, Microsoft Graph or SharePoint CSOM requests. If the provided functionality is not meeting your needs you do have the option to execute SPO REST or Microsoft Graph requests yourselves, as explained in this article.</p>
<p>In the remainder of this article you'll see a lot of <code>context</code> use: in this case this is a <code>PnPContext</code> which was obtained via the <code>PnPContextFactory</code> as explained in the <a href="readme.html">overview article</a> and show below:</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // See next chapter on how to use the PnPContext
}
</code></pre>
<h2 id="general-concepts">General concepts</h2>
<p>To perform a custom API request you use the <code>ExecuteRequestAsync</code> or <code>ExecuteRequest</code> methods providing as input a <code>ApiRequest</code> holding the information for making the API call. You can use these methods on any domain model object (e.g. <code>Web</code>, <code>List</code>, <code>Team</code>) and this will not impact the call. However calling the <code>ExecuteRequestAsync</code> or <code>ExecuteRequest</code> methods on the correct domain model object enables you to use the tokens in your API call. Following tokens can be used:</p>
<table>
<thead>
<tr>
<th>Token</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{Id}</code></td>
<td>Value of the SharePoint Id property of the current model instance (e.g. List).</td>
</tr>
<tr>
<td><code>{Parent.Id}</code></td>
<td>Value of the SharePoint Id property of the current model's parent instance (e.g. Web for a List --&gt; ListCollection is skipped in this approach).</td>
</tr>
<tr>
<td><code>{GraphId}</code></td>
<td>Value of the Microsoft Graph Id property of the current model instance (e.g. TeamChannel).</td>
</tr>
<tr>
<td><code>{Parent.GraphId}</code></td>
<td>Value of the Microsoft Graph Id property of the current model's parent instance (e.g. Team for a TeamChannel --&gt; TeamChannelCollection is skipped in this approach).</td>
</tr>
<tr>
<td><code>{Site.GroupId}</code></td>
<td>Id value of the Microsoft 365 Group connected to the Site loaded in the current PnPContext (Id is the same for SharePoint REST as Microsoft Graph usage).</td>
</tr>
<tr>
<td><code>{Site.Id}</code></td>
<td>SharePoint Id value of the Site loaded in the current PnPContext.</td>
</tr>
<tr>
<td><code>{Web.Id}</code></td>
<td>SharePoint Id value of the Web loaded in the current PnPContext.</td>
</tr>
<tr>
<td><code>{Web.GraphId}</code></td>
<td>Microsoft Graph Id value of the Web loaded in the current PnPContext.</td>
</tr>
<tr>
<td><code>{List.Id}</code></td>
<td>SharePoint Id value of the List loaded in the current PnPContext (works only when the target object is of type List or ListItem).</td>
</tr>
<tr>
<td><code>{hostname}</code></td>
<td>Host name of the current site (so for <a href="https://contoso.sharepoint.com/sites/team1">https://contoso.sharepoint.com/sites/team1</a> this is contoso.sharepoint.com)</td>
</tr>
<tr>
<td><code>{serverrelativepath}</code></td>
<td>Server relative path of the current site (so for <a href="https://contoso.sharepoint.com/sites/team1">https://contoso.sharepoint.com/sites/team1</a> this is /sites/team1)</td>
</tr>
</tbody>
</table>
<p>The returned response is of type <code>ApiRequestResponse</code> and contains the JSON result, the HTTP result code, the original <code>ApiRequest</code> instance and optional extra HTTP headers returned by the call.</p>
<h2 id="making-a-custom-spo-rest-request">Making a custom SPO REST request</h2>
<p>Below sample shows how you can perform a custom REST request on the current web and on a web in another site collection:</p>
<pre><code class="lang-csharp">// Custom SPO REST request for the current connected web
// Will result in a GET https://contoso.sharepoint.com/sites/currentsite/_api/web
var apiRequest = new ApiRequest(ApiRequestType.SPORest, &quot;_api/web&quot;);
var response = context.Web.ExecuteRequest(apiRequest);

// Parse the json response returned via response.Response

// Custom SPO REST Request for another web
// Will result in a GET https://contoso.sharepoint.com/sites/anothersite/_api/web
var apiRequest = new ApiRequest(ApiRequestType.SPORest, &quot;https://contoso.sharepoint.com/sites/anothersite/_api/web&quot;);
var response = await context.Web.ExecuteRequestAsync(apiRequest);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>When you're using text content (e.g. json for the request body) then you need to ensure it's correctly encoded. Using the default System.Text.Json library will handle unicode characters automatically. When using Newtonsoft then use the <code>JsonSerializerSettings.StringEscapeHandling</code> property of the <code>JsonSerializerSettings</code> class.</p>
</div>
<h2 id="making-a-custom-microsoft-graph-request">Making a custom Microsoft Graph request</h2>
<p>Below sample shows how to make a custom Microsoft Graph request:</p>
<pre><code class="lang-csharp">// Custom Microsoft Graph request
// Will result in a GET &quot;https://graph.microsoft.com/v1.0/me&quot; 
var apiRequest = new ApiRequest(ApiRequestType.Graph, &quot;me&quot;);
var response = context.Team.ExecuteRequest(apiRequest);

// Parse the json response returned via response.Response
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>When you're using text content (e.g. json for the request body) then you need to ensure it's correctly encoded. Using the default System.Text.Json library will handle unicode characters automatically. When using Newtonsoft then use the <code>JsonSerializerSettings.StringEscapeHandling</code> property of the <code>JsonSerializerSettings</code> class.</p>
</div>
<h2 id="batching-custom-api-requests">Batching custom API requests</h2>
<p>To optimize performance it's recommended to limit the amount of server roundtrips and therefore batching custom API requests can be used. Batching requests is quite similar to interactive requests, you simply use one of the available <code>ExecuteRequestBatch</code> methods. Since batching requests implies that you'll only get a result once the batch is executed you do not get back a JSON string, instead you get an <code>IBatchSingleResult&lt;BatchResultValue&lt;string&gt;&gt;</code> which allows you to check if the batch was executed and if so get the batch result via the <code>Value</code> property.</p>
<pre><code class="lang-csharp">// Create a new batch
var batch = context.NewBatch();

// Add requests to the batch
var meResponse = context.Web.ExecuteRequestBatch(batch, new ApiRequest(ApiRequestType.Graph, &quot;me&quot;));
// Note: meResponse.IsAvailable is false
var drivesResponse = context.Web.ExecuteRequestBatch(batch, new ApiRequest(ApiRequestType.Graph, &quot;drives&quot;));
// Note: drivesResponse.IsAvailable is false

// Execute the batch
await context.ExecuteAsync(batch);

// Use the batch results
if (meResponse.IsAvailable)
{
    string meJsonResonse = meResponse.Result.Value;
}

if (drivesResponse.IsAvailable)
{
    string drivesJsonResponse = drivesResponse.Result.Value;
}
</code></pre>
<p>Batching can be used with an dedicated batch like shown in above example, but it's also possible to use the implicit batch which is always available, in that case you'd just leave out the <code>batch</code> parameter in the <code>ExecuteRequestBatch</code> methods:</p>
<pre><code class="lang-csharp">// Add requests to the batch
var meResponse = await context.Web.ExecuteRequestBatchAsync(new ApiRequest(ApiRequestType.Graph, &quot;me&quot;));
var drivesResponse = await context.Web.ExecuteRequestBatchAsync(new ApiRequest(ApiRequestType.Graph, &quot;drives&quot;));

// Execute the batch
await context.ExecuteAsync();

// Use the batch results
if (meResponse.IsAvailable)
{
    string meJsonResonse = meResponse.Result.Value;
}

if (drivesResponse.IsAvailable)
{
    string drivesJsonResponse = drivesResponse.Result.Value;
}
</code></pre>
<h2 id="handling-failing-requests-in-a-batch">Handling failing requests in a batch</h2>
<p>What if one of the requests in a batch fails? The default behavior is that a <code>SharePointRestServiceException</code> or <code>MicrosoftGraphServiceException</code> exception is thrown when the first failed request is processed, but you can also choose to get back a list of failed batch requests and then handle the follow-up in your code. To do this you need to tell the <code>Execute</code> methods to not throw an exception and collect the output of the <code>Execute</code> method. Following snippet shows how to do this:</p>
<pre><code class="lang-csharp">// Create a new batch
var batch = context.NewBatch();

// Add requests to the batch
var meResponse = await context.Web.ExecuteRequestBatchAsync(batch, new ApiRequest(ApiRequestType.Graph, &quot;me&quot;));
var drivesResponse = await context.Web.ExecuteRequestBatchAsync(batch, new ApiRequest(ApiRequestType.Graph, &quot;thiswillgiveanerror&quot;));

// Execute the batch, notice we tell here to not throw an exception and we collect the possible errors in a collection
var batchErrors = await context.ExecuteAsync(batch, false);

// Use the batch results
if (batchErrors.Any())
{
    // there were errors
}
else
{
    // all good
}
</code></pre>
<h2 id="can-i-mix-custom-api-requests-with-out-the-box-api-requests-in-a-single-batch">Can I mix custom API requests with out-the-box API requests in a single batch?</h2>
<p>Yes, this is perfectly possible, below example combines a custom API with an API request that will load a set of lists.</p>
<pre><code class="lang-csharp">// Create a new batch
var batch = context.NewBatch();

// Add requests to the batch
var result1 = await context.Web.ExecuteRequestBatchAsync(batch, new ApiRequest(ApiRequestType.Graph, &quot;_api/web&quot;));
var result2 = await context.Web.Lists
    .Where(p =&gt; p.TemplateType == ListTemplateType.GenericList)
    .QueryProperties(
        p =&gt; p.Title, p =&gt; p.TemplateType,
        p =&gt; p.ContentTypes.QueryProperties(
            p =&gt; p.Name, p =&gt; p.FieldLinks.QueryProperties(p =&gt; p.Name)))
    .AsBatchAsync(batch);

// Execute the batch
await context.ExecuteAsync(batch);
</code></pre>
<h2 id="i-want-to-specify-custom-request-headers-or-read-the-response-headers">I want to specify custom request headers or read the response headers</h2>
<p>To specify request headers you can use the <code>WithHeaders</code> extension method from the <code>PnP.Core.Model</code> namespace: using a <code>Dictionary&lt;string,string&gt;</code> you provide input headers and using a delegate your code get notified of the resulting response headers. Below are some sample:</p>
<pre><code class="lang-csharp">Dictionary&lt;string, string&gt; extraHeaders = new Dictionary&lt;string, string&gt;() { { &quot;myheader&quot;, &quot;myheadervalue&quot; } };

// Use WithHeaders on custom API request, process the returned response headers
var meResponse = await context.Web.WithHeaders(extraHeaders, (responseHeaders) =&gt; { /* process the response headers */ }).ExecuteRequestBatchAsync(batch, new ApiRequest(ApiRequestType.Graph, &quot;me&quot;));

// Use WithHeaders on OOB API request, ignore the response headers
context.Web.WithHeaders(extraHeaders).Load(p =&gt; p.All);
</code></pre>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>    
    <img src="https://m365-visitor-stats.azurewebsites.net/pnpcoresdk/docs">
  </body>
</html>