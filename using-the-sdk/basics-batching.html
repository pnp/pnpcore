<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html lang="en">
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using batching | PnP Core SDK </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using batching | PnP Core SDK ">
    <meta name="generator" content="docfx 2.59.2.0">
    <meta name="description" content="The PnP Core SDK is a modern .NET SDK designed to work for Microsoft 365. It provides a unified object model for working with SharePoint Online and Teams which is agnostic to the underlying API's being called.">
    <link rel="shortcut icon" href="https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <label class="glyphicon glyphicon-search" for="search-query"></label>
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
                  <div class="contribution-panel mobile-hide pull-right">
                      <a href="https://github.com/pnp/pnpcore/blob/dev/docs/using-the-sdk/basics-batching.md/#L1" title="Improve this Doc" class="improve-doc-lg"><i class="glyphicon glyphicon-pencil"></i></a>
                  </div>
                    <h1 id="using-batching">Using batching</h1>

<p>The PnP Core SDK has been built from the ground up with batching in mind, more precisely almost all requests (gets, posts, etc) are executed via the respective SharePoint REST and Microsoft Graph batch endpoints. If you for example load the Title property of an IWeb then that request is issued via the batch endpoint where the batch consists of a single request. When you write code you can however also add more requests to a batch, effectively improving performance as you're preventing unnecessary network calls.</p>
<p>In the remainder of this article you'll see a lot of <code>context</code> use: in this case this is a <code>PnPContext</code> which was obtained via the <code>PnPContextFactory</code> as explained in the <a href="readme.html">overview article</a> and show below:</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    // See next chapter on how to use the PnPContext for batching requests
}
</code></pre>
<h2 id="a-typical-use-case">A typical use case</h2>
<p>When you want to add items to a list you can do that one by one or you can group the items to add in a single batch and send that batch via one of the Execute methods, the latter approach is much faster and as easy to code as the first.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    var list = await web.Lists.AddAsync(&quot;Demo&quot;, ListTemplateType.GenericList);

    // Approach A: no batching
    for (int i = 0; i &lt; 10; i++)
    {
        Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
        {
            { &quot;Title&quot;, $&quot;Item {i}&quot; }
        };
        
        // Add &quot;list item add&quot; to the server (= roundtrip)
        await list.Items.AddAsync(values);
    }

    // Approach B: batching
    for (int i = 0; i &lt; 10; i++)
    {
        Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
        {
            { &quot;Title&quot;, $&quot;Item {i}&quot; }
        };
        
        // Add &quot;list item add&quot; to current batch (= NO roundtrip)
        await list.Items.AddBatchAsync(values);
    }
    
    // send the batch to server (= roundtrip)
    await context.ExecuteAsync();
}
</code></pre>
<p>For most of the methods in the PnP Core SDK you'll find equivalent batch methods: the followed convention is adding the &quot;Batch&quot; suffix e.g. we've a Get and GetAsync but also a GetBatch and GetBatchAsync. The &quot;batch&quot; methods have an override that allows you to specify a batch to add the request to, if you don't specify a batch the request will be added to the &quot;current&quot; batch. Creating a new batch can be done using the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Services.PnPContext.html#PnP_Core_Services_PnPContext_NewBatch">NewBatch method</a> on PnPContext. Using a dedicated batch object you can be 100% no other code path in your application adds requests to your batch.</p>
<pre><code class="lang-csharp">using (var context = await pnpContextFactory.CreateAsync(&quot;SiteToWorkWith&quot;))
{
    var list = await web.Lists.AddAsync(&quot;Demo&quot;, ListTemplateType.GenericList);

    // Approach A: batching via the current batch
    for (int i = 0; i &lt; 10; i++)
    {
        Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
        {
            { &quot;Title&quot;, $&quot;Item {i}&quot; }
        };
        
        // Add &quot;list item add&quot; to current batch (= NO roundtrip)
        await list.Items.AddBatchAsync(values);
    }
    
    // send the batch to server (= roundtrip)
    await context.ExecuteAsync();

    // Approach B: batching via the specific batch
    var newBatch = context.NewBatch();
    for (int i = 0; i &lt; 10; i++)
    {
        Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
        {
            { &quot;Title&quot;, $&quot;Item {i}&quot; }
        };
        
        // Add &quot;list item add&quot; to current batch (= NO roundtrip)
        await list.Items.AddBatchAsync(newBatch, values);
    }
    
    // send the batch to server (= roundtrip)
    await context.ExecuteAsync(newBatch);
}
</code></pre>
<h2 id="loading-data-in-batch">Loading data in batch</h2>
<p>While above example showed how to add items in a batch it's also possible to batch queries that load data. When you want to load data into the context you can use the <code>LoadBatch</code> or <code>LoadBatchAsync</code> methods, loading data into a variable can be done using the respective <code>GetBatchAsync</code> and <code>GetBatch</code> methods.</p>
<pre><code class="lang-csharp">// Create a single batch that loads SharePoint Site and Web data + Teams Members. As this involves REST and Graph the net
// result will issue two batch requests going to Microsoft 365. One SharePoint batch request for the web + site data, one Microsoft
// Graph batch request for the Teams data
var batch = context.NewBatch();
await context.Web.LoadBatchAsync(batch, p =&gt; p.Lists, p =&gt; p.Features);
await context.Site.LoadBatchAsync(batch, p =&gt; p.Features, p =&gt; p.IsHubSite);
await context.Team.LoadBatchAsync(batch, p =&gt; p.Members);
await context.ExecuteAsync(batch);

// Pick a list from the in batch loaded lists
var myList = context.Web.Lists.AsRequested().FirstOrDefault(l =&gt; l.Title == &quot;Site Pages&quot;);

// Iterate over the in batch loaded Teams members
foreach(var member in context.Team.Members.AsRequested())
{
    // do something with the members
}
</code></pre>
<p>While the above approach loads data via a batch request it does load all data in a collection, all lists, features and members were loaded. What if you would want to perform a filtered batch load? For that you can use the <code>AsBatchAsync</code> and <code>AsBatch</code> methods. When you batch load data into a variable you can use the <code>IsAvailable</code> property of the variable to check if the batch was executed before consuming the data. In case of a collection the returned variable (e.g. <code>siteAssets</code> in below sample) simply allows you to query the results.</p>
<pre><code class="lang-csharp">// Do a two list gets with filter and custom properties specifying the data to load
var siteAssets = await context.Web.Lists.QueryProperties(
        p =&gt; p.Title, p =&gt; p.TemplateType,
        p =&gt; p.ContentTypes.QueryProperties(
            p =&gt; p.Name, 
            p =&gt; p.FieldLinks.QueryProperties(p =&gt; p.Name)))
    .Where(p =&gt; p.Title == &quot;Site Assets&quot;)
    .AsBatchAsync();

var sitePages = await context.Web.Lists.QueryProperties(
        p =&gt; p.Title, p =&gt; p.TemplateType,
        p =&gt; p.ContentTypes.QueryProperties(
            p =&gt; p.Name, 
            p =&gt; p.FieldLinks.QueryProperties(p =&gt; p.Name)))
    .Where(p =&gt; p.Title == &quot;Site Pages&quot;)
    .AsBatchAsync();

// Batch results are not available right now
Assert.IsFalse(siteAssets.IsAvailable);
Assert.IsFalse(sitePages.IsAvailable);

// Execute the batch
await context.ExecuteAsync();

// Batch results are now available
Assert.IsTrue(siteAssets.IsAvailable);
Assert.IsTrue(sitePages.IsAvailable);

// Get the loaded data to use it
var siteAssetsList = siteAssets.AsEnumerable().First();
var sitePagesList = sitePages.AsEnumerable().First();
</code></pre>
<p>In case of a collection the returned variable (e.g. <code>siteAssets</code> in above sample) simply allows you to query the results. When you're returning a simple type or a single model (e.g. <code>web</code> and <code>site</code> in below sample) you can access the batch loaded data via the <code>Result</code> property. Checking whether the batch was executed still happens via the <code>IsAvailable</code> property.</p>
<pre><code class="lang-csharp">var batch = context.NewBatch();
var web = await context.Web.GetBatchAsync(batch, p =&gt; p.Lists, p =&gt; p.Features);
var site = await context.Site.GetBatchAsync(batch, p =&gt; p.Features, p =&gt; p.IsHubSite);

// Batch results are not available right now
Assert.IsFalse(web.IsAvailable);

// Execute the batch
await context.ExecuteAsync(batch);

// Batch results are now available
Assert.IsTrue(web.IsAvailable);

// Pick a list from the in batch loaded lists
var myList = web.Result.Lists.AsRequested().FirstOrDefault(l =&gt; l.Title == &quot;Site Pages&quot;);
</code></pre>
<h2 id="batch-limits">Batch limits</h2>
<p>PnP Core SDK is not imposing limits on the number of requests you can add to a single batch before executing the batch, but internally the SDK uses the official limits being maximum 20 requests for a Graph batch and 100 requests for a SharePoint REST batch. What that means is that you for example can add 1000 items into a single batch and execute that batch, during execution that batch will then be split into 10 batches of 100 items and each of these 10 batches will be executed sequentially resulting in 10 network calls to the respective batch endpoint.</p>
<h2 id="handling-batch-failures">Handling batch failures</h2>
<p>The default behavior is that whenever a batch response is processed and a failing request inside the batch was detected an exception is thrown. This default mode is useful when you build small batches. However, when you perform bulk adds or bulk deletions then you don't want your batch processing being interrupted on a single failure. A sample case could be this: imagine you've created a batch to delete all list items from a list, but in parallel someone else already deleted an item you're also deleting via the submitted batch. With the default batch behavior you'll get an exception stating an item was not found, but you can turn off the <code>ThrowOnError</code> setting by providing it to the <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Services.PnPContext.html#collapsible-PnP_Core_Services_PnPContext_ExecuteAsync_System_Boolean_">ExecuteAsync</a> method and then the batch continues and you'll get a list of <a href="https://pnp.github.io/pnpcore/api/PnP.Core.Services.BatchResult.html">BatchResult</a> (= the errors) which you then have to handle in your code.</p>
<pre><code class="lang-csharp">// Create a list
var myList = await context.Web.Lists.AddAsync(listTitle, ListTemplateType.GenericList);

// Add 150 items to the list
for (int i = 1; i &lt;= 150; i++)
{
    Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
        {
            { &quot;Title&quot;, $&quot;Item {i}&quot; }
        };

    await myList.Items.AddBatchAsync(values);
}
await context.ExecuteAsync();

// Delete some items from within both 1..100 and 101..150 sets
await myList.Items.DeleteByIdBatchAsync(5);
await myList.Items.DeleteByIdBatchAsync(50);
await myList.Items.DeleteByIdBatchAsync(125);
await context.ExecuteAsync();

// Build a batch to delete all 150 items
for (int i = 1; i &lt;= 150; i++)
{
    await myList.Items.DeleteByIdBatchAsync(i);
}

// Execute the batch without throwing an error, gets you a collection of errors back
var batchResponse = await context.ExecuteAsync(false);

foreach(var batchResponse in batchResponses)
{
    // Do something with the failed request
}

</code></pre>
<p>It's also possible to track additional request information (e.g. the id of the deleted items) and then link the failing requests in a batch back to that tracked information. Below code snippet shows how this could be implemented.</p>
<pre><code class="lang-csharp">// Create a list
var myList = await context.Web.Lists.AddAsync(listTitle, ListTemplateType.GenericList);

// Add 150 items to the list
for (int i = 1; i &lt;= 150; i++)
{
    Dictionary&lt;string, object&gt; values = new Dictionary&lt;string, object&gt;
        {
            { &quot;Title&quot;, $&quot;Item {i}&quot; }
        };

    await myList.Items.AddBatchAsync(values);
}
await context.ExecuteAsync();

// Delete some items from within both 1..100 and 101..150 sets
await myList.Items.DeleteByIdBatchAsync(5);
await myList.Items.DeleteByIdBatchAsync(50);
await myList.Items.DeleteByIdBatchAsync(125);
await context.ExecuteAsync();

var batch = context.NewBatch();

// Sample on how to track additional information for a batch request
Dictionary&lt;Guid, int&gt; deletedListItemIds = new();

for (int i = 1; i &lt;= 150; i++)
{
    await myList.Items.DeleteByIdBatchAsync(batch, i);
    deletedListItemIds.Add(batch.Requests.Last().Value.Id, i);
}

// Execute the batch without throwing an error, should get a result collection back
var batchResponse = await context.ExecuteAsync(batch, false);                

// Find the corresponding batch requests
foreach (var errorResult in errorResults)
{
    var failedListItemIdDelete = deletedListItemIds.FirstOrDefault(p=&gt; p.Key == errorResult.BatchRequestId).Value;
}
</code></pre>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>PnP Core SDK<br>Generated by <strong><a href='https://dotnet.github.io/docfx' alt='Doc FX Website'>DocFX</a></strong> with <strong><a href='https://ovasquez.github.io/docfx-material' alt='DocFx Material Theme'>Material UI</a></strong></span>
            
            <img src="https://telemetry.sharepointpnp.com/@pnp.github.io/index/" alt="spacer">
          </div>
        </div>
      </footer>    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>    
    <img src="https://m365-visitor-stats.azurewebsites.net/pnpcoresdk/docs">
  </body>
</html>